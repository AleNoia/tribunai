import { useState, useEffect, useCallback } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { toast } from "sonner";
import { z } from "zod";
import { useAuth } from "@/hooks/useAuth";
import { useRouter } from "next/navigation";
import { createClient } from "@/lib/supabase/client";
import { logger } from "@/lib/logger";

// Enums para steps
export enum RegisterStep {
  Dados = 1,
  ConfirmacaoEmail = 2,
  EscolhaPlano = 3,
  Pagamento = 4,
}

// Constantes dos planos
export const PLAN_PRICES = {
  monthly: 2000, // R$ 20,00
  annual: 18000, // R$ 180,00
  free: 0,
};

const createRegisterSchema = () =>
  z
    .object({
      name: z
        .string()
        .min(1, "O nome √© obrigat√≥rio")
        .min(3, "O nome deve ter pelo menos 3 caracteres"),
      email: z.string().min(1, "O email √© obrigat√≥rio").email("Email inv√°lido"),
      password: z
        .string()
        .min(6, "A senha deve ter pelo menos 6 caracteres")
        .regex(/[A-Z]/, "A senha deve conter pelo menos uma letra mai√∫scula")
        .regex(/[a-z]/, "A senha deve conter pelo menos uma letra min√∫scula")
        .regex(/[0-9]/, "A senha deve conter pelo menos um n√∫mero"),
      confirmPassword: z.string(),
    })
    .refine((data) => data.password === data.confirmPassword, {
      message: "As senhas devem coincidir",
      path: ["confirmPassword"],
    });

export type RegisterFormValues = z.infer<ReturnType<typeof createRegisterSchema>>;

export function useRegisterFlow() {
  const { user, refreshUser } = useAuth();
  const router = useRouter();
  const supabase = createClient();
  
  const [step, setStep] = useState<RegisterStep>(RegisterStep.Dados);
  const [isEmailSent, setIsEmailSent] = useState(false);
  const [isEmailSending, setIsEmailSending] = useState(false);
  const [showPassword, setShowPassword] = useState(false);
  const [selectedPlan, setSelectedPlan] = useState<string | undefined>(undefined);
  const [resendCountdown, setResendCountdown] = useState(0);
  const [autoEmailSent, setAutoEmailSent] = useState(false);

  const form = useForm<RegisterFormValues>({
    resolver: zodResolver(createRegisterSchema()),
    defaultValues: {
      name: "",
      email: "",
      password: "",
      confirmPassword: "",
    },
  });

  // Fun√ß√£o centralizada para verificar confirma√ß√£o de email
  const checkEmailConfirmation = useCallback(async (userId: string) => {
    try {
      logger.info("Verificando confirma√ß√£o de email", {
        action: "check_email_confirmation",
        userId,
      });

      const response = await fetch("/api/auth/confirm", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ userId }),
      });

      const result = await response.json();

      if (!response.ok) {
        logger.error("Erro na confirma√ß√£o de email", {
          action: "email_confirmation_failed",
          userId,
          metadata: { error: result.error, status: response.status },
        });
        return { success: false, error: result.error };
      }

      logger.info("Email confirmado com sucesso", {
        action: "email_confirmation_success",
        userId,
      });

      return { success: true, data: result };
    } catch (error) {
      logger.error("Erro ao verificar confirma√ß√£o", {
        action: "email_confirmation_error",
        userId,
        metadata: {
          error: error instanceof Error ? error.message : "Erro desconhecido",
        },
      });
      return { success: false, error: "Erro interno" };
    }
  }, []);

  // Fun√ß√£o para verificar plano do usu√°rio
  const checkUserPlan = useCallback(async () => {
    try {
      const {
        data: { session },
      } = await supabase.auth.getSession();
      const token = session?.access_token;

      if (!token) {
        toast.error("Usu√°rio n√£o autenticado. Fa√ßa login novamente.");
        return null;
      }

      const response = await fetch("/api/users/get-plan", {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${token}`,
        },
      });

      const result = await response.json();
      return response.ok ? result : null;
    } catch (error) {
      logger.error("Erro ao verificar plano do usu√°rio", {
        action: "check_user_plan_error",
        metadata: {
          error: error instanceof Error ? error.message : "Erro desconhecido",
        },
      });
      return null;
    }
  }, [supabase]);

  // Fun√ß√£o para login autom√°tico
  const autoLogin = useCallback(
    async (email: string, password: string) => {
      try {
        logger.info("Tentando login autom√°tico", {
          action: "auto_login_started",
          metadata: { email: email.toLowerCase() },
        });

        const { error } = await supabase.auth.signInWithPassword({
          email,
          password,
        });

        if (error) {
          logger.error("Erro no login autom√°tico", {
            action: "auto_login_error",
            metadata: {
              email: email.toLowerCase(),
              error: error.message,
            },
          });
          throw error;
        }

        logger.info("Login autom√°tico bem-sucedido", {
          action: "auto_login_success",
          metadata: { email: email.toLowerCase() },
        });

        return true;
      } catch (error) {
        logger.info("Login autom√°tico falhou (aguardando confirma√ß√£o)", {
          action: "auto_login_failed",
          metadata: {
            email: email.toLowerCase(),
            error: error instanceof Error ? error.message : "Erro desconhecido",
          },
        });
        // N√£o mostrar erro - √© esperado at√© o email ser confirmado
        return false;
      }
    },
    [supabase]
  );

  // Fun√ß√£o para processar checkout autom√°tico
  const processAutoCheckout = useCallback(
    async (
      user: {
        id: string;
        user_metadata?: { name?: string };
        email?: string;
      },
      plan: string
    ) => {
      try {
        const amount = PLAN_PRICES[plan as keyof typeof PLAN_PRICES];

        if (!amount || !user.id || !user.user_metadata?.name || !user.email) {
          logger.error("Dados inv√°lidos para checkout autom√°tico", {
            action: "auto_checkout_invalid_data",
            userId: user.id,
          });
          toast.error("Dados inv√°lidos para checkout autom√°tico. Tente novamente.");
          return false;
        }

        const checkoutData = {
          plan,
        };

        logger.info("Processando checkout autom√°tico", {
          action: "auto_checkout_processing",
          userId: user.id,
          metadata: { plan, amount },
        });

        const response = await fetch("/api/stripe/checkout", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(checkoutData),
        });

        const result = await response.json();
        if (!response.ok)
          throw new Error(result.error || "Erro ao processar pagamento");

        window.location.href = result.url;
        return true;
      } catch (error) {
        logger.error("Erro no checkout autom√°tico", {
          action: "auto_checkout_error",
          metadata: {
            error: error instanceof Error ? error.message : "Erro desconhecido",
          },
        });
        toast.error("Erro ao processar pagamento. Tente novamente.");
        return false;
      }
    },
    []
  );

  // useEffect principal para gerenciar o fluxo de registro
  useEffect(() => {
    const handleUserFlow = async () => {
      // Log para debug (detalhado)
      logger.info("üîÑ handleUserFlow executado", {
        action: "user_flow_check",
        metadata: { 
          hasUser: !!user,
          userId: user?.id,
          email: user?.email,
          step, 
          emailConfirmed: user?.email_confirmed_at ? true : false,
          emailConfirmedAt: user?.email_confirmed_at || null,
        }
      });

      // Se usu√°rio est√° logado com email j√° confirmado no Step 1, ir para escolha de plano
      if (user && step === RegisterStep.Dados && user.email_confirmed_at) {
        logger.info("Usu√°rio logado com email confirmado - avan√ßando para plano", {
          action: "advance_to_plan_selection",
          userId: user.id,
        });
        setStep(RegisterStep.EscolhaPlano);
        return;
      }

      // Se est√° no step de confirma√ß√£o e usu√°rio est√° logado com email confirmado
      if (step === RegisterStep.ConfirmacaoEmail) {
        console.log("üöÄ ~ handleUserFlow ~ user:", user)
        console.log("üöÄ ~ handleUserFlow ~ user.email_confirmed_at:", user?.email_confirmed_at)

        if (user && user.email_confirmed_at) {
          logger.info("‚úÖ Email confirmado - avan√ßando para escolha de plano", {
            action: "advance_to_plan_selection_after_confirmation",
            userId: user.id,
            metadata: {
              email: user.email,
              currentStep: step,
            },
          });
          
          // Verificar plano do usu√°rio
          const planResult = await checkUserPlan();

          if (
            planResult &&
            (planResult.plan === "monthly" || planResult.plan === "annual")
          ) {
            // Processar checkout autom√°tico para planos pagos
            const checkoutSuccess = await processAutoCheckout(user, planResult.plan);
            if (checkoutSuccess) return;
          }

          // Avan√ßar para escolha de plano (usu√°rio gratuito ou checkout falhou)
          setStep(RegisterStep.EscolhaPlano);
        } else {
          logger.info("Aguardando confirma√ß√£o de email", {
            action: "waiting_email_confirmation",
            metadata: {
              hasUser: !!user,
              emailConfirmed: user?.email_confirmed_at ? true : false,
              currentStep: step,
            },
          });
        }
      }
    };

    handleUserFlow();
  }, [
    user,
    step,
    checkEmailConfirmation,
    checkUserPlan,
    processAutoCheckout,
    form,
    autoLogin,
  ]);

  // Detectar quando usu√°rio volta da confirma√ß√£o (sess√£o criada pelo callback)
  useEffect(() => {
    // Se est√° no step de confirma√ß√£o e o usu√°rio acabou de fazer login
    if (step === RegisterStep.ConfirmacaoEmail && user && user.email_confirmed_at) {
      logger.info("‚úÖ Email confirmado! Usu√°rio detectado", {
        action: "email_confirmed_user_detected",
        userId: user.id,
      });
      toast.success("Email confirmado com sucesso!");
      // O useEffect principal vai cuidar de avan√ßar para o pr√≥ximo step
    }
  }, [user, step]);

  // Detectar quando usu√°rio volta para a aba (ap√≥s confirmar email em outra aba)
  useEffect(() => {
    const handleVisibilityChange = async () => {
      // Se a aba ficou vis√≠vel e estamos aguardando confirma√ß√£o
      if (!document.hidden && step === RegisterStep.ConfirmacaoEmail) {
        logger.info("Aba voltou ao foco - verificando sess√£o", {
          action: "window_focus_check_session",
          metadata: { step },
        });

        // For√ßar verifica√ß√£o da sess√£o
        const {
          data: { session },
        } = await supabase.auth.getSession();

        logger.info("Sess√£o verificada ao voltar foco", {
          action: "session_check_on_focus",
          metadata: {
            hasSession: !!session,
            hasUser: !!session?.user,
            emailConfirmed: session?.user?.email_confirmed_at ? true : false,
            email: session?.user?.email,
          },
        });

        if (session?.user?.email_confirmed_at) {
          logger.info("‚úÖ Sess√£o confirmada detectada ao voltar foco", {
            action: "session_confirmed_on_focus",
            userId: session.user.id,
          });
          
          // For√ßar atualiza√ß√£o completa da sess√£o
          await refreshUser();
          
          // Avan√ßar diretamente para Step 3 (n√£o esperar useEffect)
          logger.info("üöÄ For√ßando avan√ßo para Step 3", {
            action: "force_advance_to_step3",
            userId: session.user.id,
          });
          
          setStep(RegisterStep.EscolhaPlano);
        } else {
          logger.warn("‚ö†Ô∏è Sess√£o existe mas email ainda n√£o confirmado", {
            action: "session_not_confirmed_on_focus",
            metadata: {
              hasSession: !!session,
              userId: session?.user?.id,
            },
          });
        }
      }
    };

    document.addEventListener("visibilitychange", handleVisibilityChange);
    window.addEventListener("focus", handleVisibilityChange);

    return () => {
      document.removeEventListener("visibilitychange", handleVisibilityChange);
      window.removeEventListener("focus", handleVisibilityChange);
    };
  }, [step, supabase, refreshUser]);

  // Remover autoLogin - o callback do Supabase j√° cria a sess√£o automaticamente

  // Redirecionar para dashboard apenas se usu√°rio j√° completou TODO o fluxo
  useEffect(() => {
    const checkAndRedirect = async () => {
      // Se est√° no Step 1 com usu√°rio autenticado e email confirmado
      if (user && step === RegisterStep.Dados && user.email_confirmed_at) {
        // Verificar se usu√°rio j√° tem um plano escolhido (completou cadastro)
        const planResult = await checkUserPlan();
        
        if (planResult && planResult.plan && planResult.plan !== "free") {
          // Usu√°rio j√° completou o cadastro e tem plano pago
          logger.warn("Usu√°rio j√° completou cadastro - redirecionando para dashboard", {
            action: "redirect_completed_user",
            userId: user.id,
            metadata: { plan: planResult.plan }
          });
          router.replace("/dashboard");
        } else {
          // Usu√°rio est√° logado mas ainda n√£o escolheu plano
          // Deixa continuar o fluxo para Step 3
          logger.info("Usu√°rio autenticado mas sem plano - continuando fluxo", {
            action: "continue_registration_flow",
            userId: user.id,
          });
          setStep(RegisterStep.EscolhaPlano);
        }
      }
    };
    
    checkAndRedirect();
  }, [user, step, router, checkUserPlan]);

  const updateUserPlan = useCallback(
    async (plan: string) => {
      try {
        logger.info("üîÑ updateUserPlan - Iniciando (SIMPLIFICADO)", {
          action: "update_plan_start",
          metadata: { plan },
        });

        logger.info("üì° Chamando API /api/users/update-plan (sem verificar token no frontend)", {
          action: "update_plan_api_call_direct",
          metadata: { plan },
        });

        // Chamar API diretamente (sem verificar token aqui)
        // O backend vai verificar autentica√ß√£o usando cookies
        const response = await fetch("/api/users/update-plan", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({ plan }),
        });

        const result = await response.json();

        logger.info("üì• Resposta da API recebida", {
          action: "update_plan_api_response",
          metadata: {
            ok: response.ok,
            status: response.status,
            result,
          },
        });

        if (!response.ok) {
          logger.error("‚ùå API retornou erro", {
            action: "update_plan_api_error",
            metadata: {
              status: response.status,
              error: result.error,
            },
          });
          
          if (response.status === 401) {
            toast.error("Sess√£o expirou. Fa√ßa login novamente.");
          } else {
            toast.error(result.error || "Erro ao atualizar plano. Tente novamente.");
          }
          return false;
        }

        logger.info("‚úÖ Plano atualizado na API com sucesso", {
          action: "update_plan_api_success",
          metadata: { success: result.success },
        });

        return result.success;
      } catch (error) {
        logger.error("‚ùå Exce√ß√£o ao atualizar plano", {
          action: "update_plan_exception",
          metadata: {
            error: error instanceof Error ? error.message : "Unknown error",
          },
        });
        console.error(error);
        toast.error("Erro ao atualizar plano. Tente novamente.");
        return false;
      }
    },
    []
  );

  const generateCheckoutSession = useCallback(async () => {
    try {
      logger.info("üí≥ generateCheckoutSession - INICIANDO", {
        action: "generate_checkout_start",
        metadata: { selectedPlan },
      });

      // N√£o precisamos verificar user - a API vai verificar via cookies
      // Isso evita o problema de getUser() travar

      let currentPlan = selectedPlan;
      if (
        currentPlan !== "monthly" &&
        currentPlan !== "annual" &&
        currentPlan !== "free"
      ) {
        currentPlan = "free";
      }

      logger.info("üìã Plano validado", {
        action: "generate_checkout_plan_validated",
        metadata: { plan: currentPlan },
      });

      if (currentPlan === "free") {
        logger.info("‚úÖ Plano FREE - indo para dashboard", {
          action: "generate_checkout_free_redirect",
        });
        toast.success("Cadastro conclu√≠do!");
        router.push("/dashboard");
        return;
      }

      const checkoutData = {
        plan: currentPlan,
      };

      logger.info("üì° Chamando API /api/stripe/checkout", {
        action: "generate_checkout_api_call",
        metadata: { plan: currentPlan },
      });

      const response = await fetch("/api/stripe/checkout", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(checkoutData),
      });

      logger.info("üì• Resposta da API Stripe recebida", {
        action: "generate_checkout_api_response",
        metadata: {
          ok: response.ok,
          status: response.status,
        },
      });

      const result = await response.json();

      logger.info("üìÑ Resultado parseado", {
        action: "generate_checkout_result_parsed",
        metadata: {
          hasUrl: !!result.url,
          hasError: !!result.error,
        },
      });

      if (!response.ok) {
        logger.error("‚ùå API Stripe retornou erro", {
          action: "generate_checkout_api_error",
          metadata: {
            status: response.status,
            error: result.error,
          },
        });
        throw new Error(result.error || "Erro ao gerar checkout");
      }

      logger.info("üöÄ Redirecionando para Stripe", {
        action: "generate_checkout_redirecting",
        metadata: { url: result.url },
      });

      window.location.href = result.url;
    } catch (err) {
      logger.error("‚ùå Erro ao gerar checkout", {
        action: "generate_checkout_error",
        metadata: {
          error: err instanceof Error ? err.message : "Unknown error",
        },
      });
      toast.error(
        err instanceof Error
          ? err.message
          : "Erro ao gerar checkout. Tente novamente."
      );
    }
  }, [selectedPlan, router]);

  // Gerar Checkout quando Step 4 for carregado
  useEffect(() => {
    logger.info("üîÑ useEffect [step] - Verificando Step 4", {
      action: "check_step4",
      metadata: {
        step,
        stepName: step === 1 ? "Dados" : step === 2 ? "Email" : step === 3 ? "Plano" : step === 4 ? "Pagamento" : "Unknown",
        selectedPlan,
        isPagamento: step === RegisterStep.Pagamento,
        hasPlan: !!selectedPlan,
        notFree: selectedPlan !== "free",
      },
    });

    if (step === RegisterStep.Pagamento && selectedPlan && selectedPlan !== "free") {
      logger.info("‚úÖ Step 4 detectado - Gerando checkout", {
        action: "step4_generate_checkout",
        metadata: { plan: selectedPlan },
      });
      generateCheckoutSession();
    } else if (step === RegisterStep.Pagamento && selectedPlan === "free") {
      logger.info("‚úÖ Step 4 com plano FREE - Redirecionando para dashboard", {
        action: "step4_free_plan_redirect",
      });
      toast.success("Cadastro conclu√≠do!");
      router.push("/dashboard");
    }
  }, [step, selectedPlan, generateCheckoutSession, router]);

  const onSubmit = async () => {
    if (step === RegisterStep.Pagamento) {
      return;
    }
  };

  const handleNextStep = async () => {
    let fieldsToValidate: (keyof RegisterFormValues)[] = [];
    
    if (step === RegisterStep.Dados) {
      fieldsToValidate = ["name", "email", "password", "confirmPassword"];
      
      const isValid = await form.trigger(fieldsToValidate);
      
      if (isValid) {
        logger.info("Valida√ß√£o do Step 1 passou - avan√ßando para Step 2", {
          action: "step1_validated",
          metadata: { email: form.getValues("email") }
        });
        setStep(RegisterStep.ConfirmacaoEmail);
      } else {
        const formErrors = form.formState.errors;
        const errorMessages = Object.values(formErrors)
          .map((error) => error?.message)
          .filter(Boolean);
        if (errorMessages.length > 0) {
          toast.error(
            errorMessages[0] || "Por favor, preencha todos os campos obrigat√≥rios"
          );
        }
      }
      return;
    }
    
    if (step === RegisterStep.EscolhaPlano) {
      logger.info("üéØ Step 3: Tentando avan√ßar para pagamento", {
        action: "step3_advance_attempt",
        metadata: { selectedPlan },
      });

      if (!selectedPlan) {
        logger.warn("‚ùå Nenhum plano selecionado", {
          action: "step3_no_plan_selected",
        });
        toast.error("Por favor, selecione um plano");
        return;
      }

      logger.info("üìù Atualizando plano do usu√°rio", {
        action: "step3_updating_plan",
        metadata: { plan: selectedPlan },
      });

      const planUpdated = await updateUserPlan(selectedPlan);

      if (!planUpdated) {
        logger.error("‚ùå Falha ao atualizar plano", {
          action: "step3_update_plan_failed",
          metadata: { plan: selectedPlan },
        });
        toast.error("Erro ao atualizar plano. Tente novamente.");
        return;
      }

      logger.info("‚úÖ Plano atualizado com sucesso - Avan√ßando para Step 4", {
        action: "step3_plan_updated_success",
        metadata: { plan: selectedPlan },
      });

      // Se FREE, vai direto pro dashboard
      if (selectedPlan === "free") {
        logger.info("‚úÖ Plano FREE - Redirecionando para dashboard", {
          action: "step3_free_redirect",
        });
        toast.success("Cadastro conclu√≠do!");
        router.push("/dashboard");
        return;
      }

      // Se PAGO, gerar checkout diretamente (n√£o esperar useEffect)
      logger.info("üí≥ Plano pago - Gerando checkout IMEDIATAMENTE", {
        action: "step3_generating_checkout_directly",
        metadata: { plan: selectedPlan },
      });

      setStep(RegisterStep.Pagamento);
      
      // Gerar checkout sem esperar useEffect
      await generateCheckoutSession();
      
      return;
    }
  };

  const resendConfirmationEmail = async () => {
    try {
      const email = form.getValues("email");

      logger.info("Reenviando email de confirma√ß√£o (frontend)", {
        action: "resend_confirmation_email_frontend",
        metadata: { email: email.toLowerCase() },
      });

      const { error } = await supabase.auth.resend({
        type: "signup",
        email,
        options: {
          emailRedirectTo: `${window.location.origin}/auth/callback`,
        },
      });

      if (error) {
        logger.error("Erro ao reenviar email de confirma√ß√£o (frontend)", {
          action: "resend_confirmation_email_error_frontend",
          metadata: {
            email: email.toLowerCase(),
            error: error.message,
          },
        });
        throw error;
      }

      logger.info("Email de confirma√ß√£o reenviado com sucesso (frontend)", {
        action: "resend_confirmation_email_success_frontend",
        metadata: { email: email.toLowerCase() },
      });

      toast.success("Email de confirma√ß√£o reenviado. Verifique sua caixa de entrada.");
      setResendCountdown(13);
    } catch (error) {
      logger.error("Erro ao reenviar email de confirma√ß√£o (frontend)", {
        action: "resend_confirmation_email_failed_frontend",
        metadata: {
          email: form.getValues("email").toLowerCase(),
          error: error instanceof Error ? error.message : "Erro desconhecido",
        },
      });
      toast.error("Erro ao reenviar email de confirma√ß√£o. Tente novamente.");
    }
  };

  useEffect(() => {
    if (resendCountdown > 0) {
      const timer = setTimeout(() => setResendCountdown(resendCountdown - 1), 1000);
      return () => clearTimeout(timer);
    }
  }, [resendCountdown]);

  const handleEmailConfirmation = useCallback(async () => {
    try {
      setIsEmailSending(true);
      const formData = form.getValues();

      logger.info("Iniciando processo de registro (frontend signUp)", {
        action: "register_started_frontend",
        metadata: { email: formData.email.toLowerCase() },
      });

      // Usar signUp do cliente (frontend) para gerar link PKCE correto
      const { data, error } = await supabase.auth.signUp({
        email: formData.email,
        password: formData.password,
        options: {
          data: {
            name: formData.name,
            selectedPlan: "free",
          },
          emailRedirectTo: `${window.location.origin}/auth/callback`,
        },
      });

      if (error) {
        logger.error("Erro ao criar usu√°rio no Auth (frontend)", {
          action: "register_auth_error_frontend",
          metadata: {
            error: error.message,
            email: formData.email.toLowerCase(),
          },
        });

        if (error.message.includes('User already registered') || error.message.includes('already registered')) {
          logger.warn("Tentativa de registro com email j√° existente", {
            action: "register_duplicate_email_attempt",
            metadata: { email: formData.email.toLowerCase() },
          });
          toast.error(
            "Este email j√° est√° cadastrado. Tente outro email ou fa√ßa login."
          );
          setStep(RegisterStep.Dados);
          return;
        }

        throw error;
      }

      if (!data.user) {
        logger.error("Usu√°rio n√£o foi criado (frontend)", {
          action: "register_user_creation_failed_frontend",
        });
        throw new Error("Falha ao criar usu√°rio");
      }

      // Se n√£o h√° sess√£o, significa que precisa confirmar email
      if (data.user && !data.session) {
        logger.info("Registro bem-sucedido - confirma√ß√£o de email necess√°ria (frontend)", {
          action: "register_email_confirmation_required_frontend",
          metadata: { email: formData.email.toLowerCase(), userId: data.user.id },
        });
        setIsEmailSent(true);
        return;
      }

      // Se j√° tem sess√£o (email auto-confirmado), criar usu√°rio na tabela users
      if (data.session) {
        logger.info("Registro conclu√≠do - email j√° confirmado (frontend)", {
          action: "register_auto_confirmed_frontend",
          metadata: { email: formData.email.toLowerCase(), userId: data.user.id },
        });

        await fetch("/api/auth/confirm", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ userId: data.user.id }),
        });

        setStep(RegisterStep.EscolhaPlano);
      }
    } catch (error) {
      logger.error("Erro ao registrar usu√°rio (frontend)", {
        action: "register_error_frontend",
        metadata: {
          error: error instanceof Error ? error.message : "Erro desconhecido",
        },
      });
      toast.error(
        error instanceof Error
          ? error.message
          : "Erro ao enviar email de confirma√ß√£o. Tente novamente."
      );
    } finally {
      setIsEmailSending(false);
    }
  }, [form, supabase]);

  // Enviar email automaticamente quando entrar no step de confirma√ß√£o
  useEffect(() => {
    if (
      step === RegisterStep.ConfirmacaoEmail &&
      !isEmailSent &&
      !isEmailSending &&
      !autoEmailSent
    ) {
      setAutoEmailSent(true);
      handleEmailConfirmation();
    }
    if (step !== RegisterStep.ConfirmacaoEmail && autoEmailSent) {
      setAutoEmailSent(false);
    }
  }, [step, isEmailSent, isEmailSending, autoEmailSent, handleEmailConfirmation]);

  const handleBackToRegister = () => {
    setStep(RegisterStep.Dados);
    setIsEmailSent(false);
    setAutoEmailSent(false);
  };

  return {
    step,
    setStep,
    RegisterStep,
    form,
    isEmailSent,
    isEmailSending,
    isConfirming: false,
    showPassword,
    setShowPassword,
    selectedPlan,
    setSelectedPlan,
    resendCountdown,
    handleNextStep,
    resendConfirmationEmail,
    handleEmailConfirmation,
    handleBackToRegister,
    onSubmit,
  };
}

